<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Proiect Info</title>
  <style>
    body {
        background-image: url(backgr.jpg);
      margin: 0;
      font-family: Arial, sans-serif;
      background-size:contain;
      background-repeat:repeat-y;
    }

    /* Butonul de meniu */
    .menu-btn {
      position:fixed;
      top: 10px;
      left: 10px;
      font-size: 24px;
      background:none;
      color: white;
      border: none;
      cursor: pointer;
      z-index: 2;
    }

    /* Sidebar-ul */
    .sidebar {
      height: 100%;
      width: 0;
      position: fixed;
      top: 0;
      left: 0;
      background-color: #111;
      overflow-x: hidden;
      transition: 0.3s;
      padding-top: 60px;
      z-index: 1;
    }

    .sidebar a {
      padding: 10px 20px;
      text-decoration: none;
      font-size: 18px;
      color: white;
      display: block;
      transition: 0.2s;
    }

    .sidebar a:hover {
      background-color: #ffffff;
    }

    .close-btn {
      position: absolute;
      top: 10px;
      right: 20px;
      font-size: 30px;
      color: white;
      background: none;
      border: none;
      cursor: pointer;
    }
  </style>
</head>
<body>

  <p style="position:relative; text-align: right;color: rgb(35, 149, 216);padding: 10px;">Rezalizat de Cazacu Mihai-Alin & Draghici Cosmin-Ioan</p>
    <!-- Buton de meniu -->
  <button class="menu-btn" onclick="openSidebar()">☰</button>

  <!-- Sidebar -->
  <div id="mySidebar" class="sidebar">
    <button class="close-btn" onclick="closeSidebar()">×</button>
    <a href="#functii">Funcții</a>
    <a href="#siruri">Șiruri</a>
    <a href="#structuri">Structuri</a>
    <a href="#recursivitate">Recursivitate</a>
    <a href="#divide et impera">DIVIDE ET IMPERA</a>
  </div>

  <!-- Conținutul principal -->
  <div style="padding: 20px;color: #ffffff;">
    
    <h1 style="text-align: center;font-size:500%;font-family:'Times New Roman', Times, serif ;text-transform: uppercase;color: rgb(127, 221, 255);" id="functii">
        Funcții
    </h1>

    <p >
        <pre style="
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 40px;
    border-radius: 16px;
    color: white;
    font-size: 24px;
    box-shadow: 0 0 20px rgba(0,0,0,0.3);">
    <b>Functia Prim</b>

         bool prim (int n)
        {
            if(n<2)                     
                return 0;
            if(n==2)
                return 1;
            if(n%2==0)
                return 0;
            for(int d=3;d*d<=n;d+=2)
                if(n%d==0)
                    return 0;
            return 1;
        }               
        </pre>
    </p>
        
    <p>
              <pre style="
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 40px;
    border-radius: 16px;
    color: white;
    font-size: 24px;
    box-shadow: 0 0 20px rgba(0,0,0,0.3);">
    <b>Functia cel mare divizor comun</b>

        int cmmdc(int a,int b)
        {
            while(a!=b)
                if(a>b)
                    a-=b;
                else
                    b-=a;
            return a;
        }
      </pre>

    </p>
    <p>
        <pre style="
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 40px;
    border-radius: 16px;
    color: white;
    font-size: 24px;
    box-shadow: 0 0 20px rgba(0,0,0,0.3);">
    <b>Functia care returnează numărul zerourilor de la sfârşitul numărului n!.</b>

        int nz (int n)
        {
            int nr=0,x=5;
            while(x<=n)
                nr+=n/x,x*=5;

            return nr;
        }
        </pre>
    </p>
    <p>
        <pre style="
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 40px;
    border-radius: 16px;
    color: white;
    font-size: 24px;
    box-shadow: 0 0 20px rgba(0,0,0,0.3);">
    <b>Functia care returneaza suma factorialelor cifrelor unui numar natural</b>

    int sumfactcif(int n)
    {
        if(n==0)
            return 1;
        int s=0,f,x;
        while(n!=0)
        {
            f=1;
            x=n%10;
            while(x>1)
            {
                f=f*x;
                --x;
            }
            s+=f;
            n/=10;
        }
        return s;
    }
        </pre>
    </p>
    <p>
        <pre style="
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 40px;
    border-radius: 16px;
    color: white;
    font-size: 24px;
    box-shadow: 0 0 20px rgba(0,0,0,0.3);">
    <b>Functia returnează diferența minimă p2-p1 în care p1 şi p2 sunt numere prime și p1≤n≤p2.</b>

        bool prim (int n)
        {
            if(n<2)
                 return 0;
            if(n%2==0)
                 return 0;
            for(int d=3;d*d<=n;d+=2)
                if(n%d==0)
                    return 0;
            return 1;
        }
        int i_prim (int n)
        {
            int a=0,b=0;
            for(int i=n;i>=3 && a==0;--i)
                if(prim(i))
                    a=i;
            for(int i=n;b==0;++i)
                if(prim(i))
                    b=i;
            return b-a;
        }
        </pre>
    </p>
    <p>
        <pre style="
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 40px;
    border-radius: 16px;
    color: white;
    font-size: 24px;
    box-shadow: 0 0 20px rgba(0,0,0,0.3);">
    <b>Functia care returneaza cel mai mic numar natural x (n<=x-1) care nu este prim, cu proprietatea că în intervalul 
        [n,x] există un singur număr prim</b>

        bool prim (int n)
        {
            if(n<2)
                return 0;
            if(n==2)
                return 1;
            if(n%2==0)
                return 0;
            for(int d=3; d*d<=n; d+=2)
                if(n%d==0)
                    return 0;
            return 1;
        }

        int interval(int n)
        {
            int x=n;
            while(prim(x)==0)
                ++x;
            return x+1;
        }             
        </pre>
    </p>
    <p>
        <pre style="
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 40px;
    border-radius: 16px;
    color: white;
    font-size: 24px;
    box-shadow: 0 0 20px rgba(0,0,0,0.3);">
        <b>Să se scrie o funcție C++ care primește ca parametri două numere n și k și determină numărul format din primele k cifre 
            ale lui n. Funcția va întoarce rezultatul prin intermediul unui parametru de ieşire.</b>

            void prefix(long int n, int k, int& x)
            {
                int cn = n;
                int kcif = 0;
                while(cn)
                {
                    kcif += 1 ;
                    cn /= 10;
                }    
                int aux = kcif - k;
                int nr = 1;
                for(int i=1; i<=aux; i++) 
                    nr *= 10;
                x = n/nr;
            }
        </pre>
    </p>
    <p>
        <pre style="
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 40px;
    border-radius: 16px;
    color: white;
    font-size: 24px;
    box-shadow: 0 0 20px rgba(0,0,0,0.3);">
        <b>Funcția primește ca parametru un text de cel mult 50 de caractere, alcătuit din cuvinte separate prin câte un spațiu și 
            formate din litere mari ale alfabetului englez, urmate eventual de caracterul . (punct), dacă sunt scrise prescurtat. 
            Textul reprezintă numele unei instituții de învățământ și doar cuvintele din mulțimea {COLEGIUL, LICEUL, NATIONAL, 
            TEORETIC} pot fi prescurtate, eliminându-se ultimele lor litere. Funcția va returna tot prin intermediul parametrului s 
            numele instituției scris fără prescurtări.</b>
            
            void Prescurtat(char s[])
            {
                char w[100];
                char w1[] = "COLEGIUL";
                char w2[] = "LICEUL";
                char w3[] = "NATIONAL";
                char w4[] = "TEORETIC";
                char *p = strtok(s, " ");

                w[0] = '\0';

                while(p) 
                {
                    if(p[strlen(p) - 1] != '.')
                        strcat(w, p);
                    else {
                        p[strlen(p) - 1] = '\0';
                        if(strstr(w1, p))
                            strcat(w, w1);
                        if(strstr(w2, p))
                            strcat(w, w2);
                        if(strstr(w3, p))
                            strcat(w, w3);
                        if(strstr(w4, p))
                            strcat(w, w4);
                    }

                    p = strtok(NULL, " ");
                    if(p)
                        strcat(w, " ");
                }

                strcpy(s, w);
            }

        </pre>
    </p>
<p>
        <pre style="
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 40px;
    border-radius: 16px;
    color: white;
    font-size: 24px;
    box-shadow: 0 0 20px rgba(0,0,0,0.3);">
        <b>Un număr natural nenul se numește perfect dacă este egal cu suma divizorilor săi naturali strict mai mici decât el.
            Să se scrie o funcție C++ care, pentru doi parametri, a și b, afișează pe ecran, separate prin câte un spațiu, în ordine 
            descrescătoare,toate numerele perfecte din intervalul [a,b]. Dacă în interval nu există astfel de numere, subprogramul 
            afișează pe ecran mesajul nu exista.</b>
          
void perfect(int a,int b)
{
    int s,ok=0;
    for(int i=b; i>=a;--i)
    {
        s=0;
        for(int d=1; d<=i/2; ++d)
            if(i%d==0)
                s+=d;
        if(i==s)
        {
            ok=1;
            cout##i##' ';
        }
    }
    if(ok==0)
        cout<<"Nu exista";
}

            
        </pre>
    </p>
    <p>
        <pre style="
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 40px;
    border-radius: 16px;
    color: white;
    font-size: 24px;
    box-shadow: 0 0 20px rgba(0,0,0,0.3);">
    <b>Functia care să determina prima și ultima cifră a unui număr natural transmis ca parametru.
        Funcția va întoarce rezultatele prin intermediul unor parametri de ieşire.</b>

void detcifre(int n,int&p,int&u)
{
    if(n<10)
    {
     u=n;
     p=n;
    }
    u=n%10;
    while(n!=0)
    {
        p=n%10;
        n/=10;
    }
}           
        </pre>
    </p>




<h2 style="text-align: center;font-size:500%;font-family:'Times New Roman', Times, serif ;text-transform: uppercase;color: rgb(127, 221, 255);" id="siruri">
    Șiruri
</h2>
<p>
    <pre style="
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 40px;
    border-radius: 16px;
    color: white;
    font-size: 24px;
    box-shadow: 0 0 20px rgba(0,0,0,0.3);">
    <b>Să se scrie un program care citeşte de la tastatură o propoziţie formată din mai multe cuvinte separate prin spaţii şi 
        transformă prima şi ultima literă a fiecărui cuvânt în literă mare.</b>
        
        #include #iostream>
        #include #string.h>
        #include #cstring>
        using namespace std;

        int main()
        {
            char s[256];
            cin.get(s,256);
            if(s[0]>='a' && s[0]<='z')
                s[0]=s[0]-('a'-'A');
            if(s[strlen(s)-1]>='a'&& s[strlen(s)-1]<='z')
                s[strlen(s)-1]=s[strlen(s)-1]-32;
            for(int i=1;i<strlen(s)-1;++i)
                if(s[i]>='a' && s[i]<='z'&& (s[i-1]==' '|| s[i+1]==' ') )
                    s[i]=s[i]-('a'-'A');
            cout<#s;
        }
    </pre>
</p>
<p>
    <pre style="
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 40px;
    border-radius: 16px;
    color: white;
    font-size: 24px;
    box-shadow: 0 0 20px rgba(0,0,0,0.3);">
    <b>Să se scrie un program care citeşte de la tastatură un cuvănt şi afişează pe ecran toate cuvintele care se pot obţine 
        prin eliminarea unei singure litere din cuvântul citit.</b>

        #include #iostream>
        #include #cstring>
        using namespace std;

        int main()
        {
            char s[101],aux[101],copie[101];
            cin.get(s,101);
            strcpy(copie,s);
            for(int i=0;i<=strlen(s)-1;++i)
            {
                strcpy(aux,s+i+1);
                strcpy(s+i,aux);
                cout<#s<<'\n';
                strcpy(s,copie);
            }
            return 0;
        }
    </pre>
</p>
<p>
    <pre style="
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 40px;
    border-radius: 16px;
    color: white;
    font-size: 24px;
    box-shadow: 0 0 20px rgba(0,0,0,0.3);">
    <b>Fiind dat un cuvânt s, format numai din litere, și un cod c, de aceeași lungime cu s, format numai din cifre, numim 
        codificare a lui s pe baza codului c operația de construire a unui nou șir, în care inițial se copiază prima literă 
        din s, apoi, parcurgând de la stânga la dreapta restul șirului s, se adaugă litera curentă la începutul noului șir, 
        dacă cifra corespunzătoare de pe aceeași poziție în c este pară, sau la finalul noului șir, în caz contrar.</b>

    <b>Scrieţi un program care citește de la tastatură, de pe linii diferite, două cuvinte, notate cu s și c, fiecare având cel 
        mult 100 de caractere, s fiind format doar din litere mici ale alfabetului englez, iar c fiind format doar din cifre. 
        Programul construiește în memorie și afișează pe ecran cuvântul obținut prin codificarea lui s pe baza lui c, dacă cele 
        două cuvinte au aceeași lungime, sau mesajul cod incorect, în caz contrar.</b>

        #include #iostream>
        #include #cstring>
        using namespace std;

        int main()
        {
            char s[101],t[101],c[101];
            int k=0;
            cin.getline(s,101);
            cin.getline(c,101);
            if(strlen(s)==strlen(c))
            {
                for(int i=strlen(s)-1;i>=0;--i)
                if(strchr("02468",c[i]))
                {
                    t[k]=s[i];
                    ++k;
                }

            for(int i=0;i<=strlen(s)-1;++i)
                if(strchr("13579",c[i]))
                {
                    t[k]=s[i];
                    ++k;
                }

            t[k]='\0';
            cout<#t;
            }
            else
                cout<<"cod incorect";

            return 0;
        }
    </pre>
</p>
<p>
    <pre style="
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 40px;
    border-radius: 16px;
    color: white;
    font-size: 24px;
    box-shadow: 0 0 20px rgba(0,0,0,0.3);">
    <b>Se dau două şiruri de caractere s şi t. Să se elimine din s toate apariţiile lui t.</b>

        #include #iostream>
        #include #cstring>
        using namespace std;

        int main()
        {
            char s[256],t[256],*p;
            int k=0;
            cin.getline(s,256);
            cin.getline(t,256);
            p=strstr(s,t);
            while(p)
            {
                k=p-s;
                char aux[256];
                strcpy(aux,s+k+strlen(t));
                strcpy(s+k,aux);
                p=strstr(s,t);
            }
            cout<#s;
            return 0;
        }
    </pre>
</p>
<p>
<pre style="
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 40px;
    border-radius: 16px;
    color: white;
    font-size: 24px;
    box-shadow: 0 0 20px rgba(0,0,0,0.3);">
    <b>Se dă o propoziție formată din litere mici ale alfabetului englez, spații și semnele de punctuație ,.. 
        Determinați un cuvânt palindrom din propoziție, primul în ordine alfabetică</b>

#include <iostream>
#include <cstring>

using namespace std;

int f(char s[256])
{
    int n=strlen(s);
    for(int i=0; i<=n/2-1; ++i)
        if(s[i]!=s[n-1-i])
            return 0;
    return 1;
}
int main()
{
    char s[256],*p,m[10]="zzzzzzzzz";
    cin.getline(s,256);
    p=strtok(s," .,");
    int ok=0;
    while(p)
    {
        if(f(p))
            if(strcmp(p,m)<0)
            {
                strcpy(m,p);
                ok=1;
            }
        p=strtok(NULL," .,");
    }
    if(ok)
        cout<#m;
    else
        cout<#"IMPOSIBIL";
    return 0;
}
    </pre>
</p>
<p>
    <pre style="
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 40px;
    border-radius: 16px;
    color: white;
    font-size: 24px;
    box-shadow: 0 0 20px rgba(0,0,0,0.3);">
        <b>Se citește un număr n, și n versuri dintr-o poezie. Fiecare vers ocupă un rând și conține litere mari și 
            mici ale alfabetului englez, spații, și semne de punctuație . , ! ?. Să se elimine din fiecare vers toate 
            semnele de punctuație, mai puțin cel aflat la final.</b>

            #include #iostream>
            #include #cstring>
            #include #string.h>
            using namespace std;

            int main()
            {
                char s[256],t[256];
                int n,nr=0;
                cin>>n;
                for(int i=0; i<=n; i++)
                {
                    cin.getline (s,256);
                    for(int j=strlen(s)-2;j>=0;j--)
                    {
                        if(!isalpha(s[j]) && s[j]!=32)
                        {
                            strcpy(t,s+j+1);
                            strcpy(s+j,t);
                        }
                        nr++;
                    }
                    if(nr)
                    cout<#s<#endl;
                }

                return 0;
            }
    </pre>
</p>
    <p>
        <pre style="
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 40px;
    border-radius: 16px;
    color: white;
    font-size: 24px;
    box-shadow: 0 0 20px rgba(0,0,0,0.3);">
    <b>Se dau două cuvinte şi o propoziţie. Să se înlocuiască în propoziţie fiecare apariţie a primului cuvânt cu al doilea.</b>

        #include #fstream>
        #include #iostream>
        #include #cstring>
        using namespace std;
        ifstream fin("inlocuirecuvant.in");
        ofstream fout("inlocuirecuvant.out");

        int main()
        {
            char s[101],a[11],b[11],*p,aux[101];
            int k, lung_a;
            fin>>a>>b;
            lung_a = strlen(a);
            fin.get();
            fin.getline(s,101);
            p=strstr(s,a);
            while(p)
            {
                k=p-s;   
                if ((s[k-1] == ' ' && s[k + lung_a ]== ' ' && k > 0)  || (k ==0 && s[k + lung_a ]== ' ') 
                    || (s[k-1] == ' ' && s[k + lung_a ]== '\0'))
                        {
                        strcpy(aux,p + lung_a);
                        strcpy(p,b);
                        strcat(p,aux);
                        }
                else
                        p += lung_a;
                p=strstr(p,a);
            }
            fout<#s;

            return 0;
        }
        </pre>
    </p>
    <p>
        <pre style="
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 40px;
    border-radius: 16px;
    color: white;
    font-size: 24px;
    box-shadow: 0 0 20px rgba(0,0,0,0.3);">
    <b> Se dau două şiruri de caractere s şi t. Să se elimine din s doar ultima apariţie a lui t.</b>
    #include <iostream>
    #include <cstring>

    using namespace std;

    int main()
    {
        int k;
        char s[256],t[256],*p,aux[256];
        cin.getline(s,256);
        cin.get(t,256);
        p=strstr(s,t);
        while(p)
        {
            k=p-s;
            p=strstr(p+1,t);
        }
        if(k!=0)
        {
            strcpy(aux,s+k+strlen(t));
            strcpy(s+k,aux);
        }
            cout<#s;

        return 0;
    }

        </pre>
    </p>
     <p>
        <pre style="
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 40px;
    border-radius: 16px;
    color: white;
    font-size: 24px;
    box-shadow: 0 0 20px rgba(0,0,0,0.3);">
    <b> Se dă un șir de caractere care conține cuvinte formate doar din litere mici și mari ale alfabetului englez,separate 
        printr-un spațiu.Să se afișeze cuvintele din șir, fiecare fiind urmat de inversul său. Cuvintele afișate sunt 
        separate printr-un spațiu.</b>
    
        #include #iostream>
        #include #cstring>

        using namespace std;

        int main()
        {
            char s[256],*p;
            cin.getline(s,256);
            p=strtok(s," ");
            while(p)
            {
                cout<#p<#' ';
                for(int i=strlen(p)-1;i>=0;--i)
                    cout<#p[i];
                cout<<' ';
                p=strtok(NULL," ");
            }

            return 0;
        }

        </pre>
    </p>
        <p>
        <pre style="
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 40px;
    border-radius: 16px;
    color: white;
    font-size: 24px;
    box-shadow: 0 0 20px rgba(0,0,0,0.3);">
    <b>Se dă un şir de caractere ce conţine cuvinte formate din litere mici ale alfabetului englez,separate prin unul sau mai 
        multe spații.Înaintea primului cuvânt nu există spații, și nici după ultimul. Să se determine numărul de cuvinte 
        din șir în care apare litera a.</b>
    
        #include #iostream>
        #include #cstring>

        using namespace std;

        int main()
        {
            int nr=0;
            char s[256],*p;
            cin.getline(s,256);
            p=strtok(s," ");
            while(p)
            {
                for(int i=0; i<=strlen(p)-1; ++i)
                    if(strchr("a",p[i]))
                        {
                            ++nr;
                            break;
                        }
                p=strtok(NULL," ");
            }
            cout<#nr;
            return 0;
        }

        </pre>
    </p>
    
    <h3 style="text-align: center;font-size:500%;font-family:'Times New Roman', Times, serif ;text-transform: uppercase;color: rgb(127, 221, 255);" id="structuri">
        Structuri
    </h3>

    <p>
        <pre style="
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 40px;
    border-radius: 16px;
    color: white;
    font-size: 24px;
    box-shadow: 0 0 20px rgba(0,0,0,0.3);">
    <b>Știind că densitatea unui oraș este egală cu raportul dintre numărul de locuitori
    și suprafața acestuia (exprimată în km2), indicați o expresie a cărei valoare este egală cu densitatea primului oraș.</b>

    struct recensamant
    {   char nume[21];
        int nrLocuitori;
        float suprafata;
    } oras[100];

Raspuns:oras[0].nrLocuitori/oras[0].suprafata
        </pre>
    </p>
    
    <p>
        <pre style="
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 40px;
    border-radius: 16px;
    color: white;
    font-size: 24px;
    box-shadow: 0 0 20px rgba(0,0,0,0.3);">
    <b>Volumul paralelipipedului este egal cu produsul celor trei dimensiuni ale sale. 
 Indicați o instrucțiune prin care i se atribuie variabilei reale v valoarea volumului paralelipipedului corespunzător variabilei p.</b>

struct paralelipiped
{ float lg,lt,h;
}p;

Raspuns:v=p.lg*p.lt*p.h;
        </pre>
    </p>
       <p>
        <pre style="
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 40px;
    border-radius: 16px;
    color: white;
    font-size: 24px;
    box-shadow: 0 0 20px rgba(0,0,0,0.3);">
<b>Se consideră declarările de mai jos, în care variabila ev memorează date despre un anumit elev.
care este instrucţiunea C/C++ prin care se iniţializează anul naşterii acestui elev cu valoarea 1998.</b>

struct data{
 int zi;
 int luna;
 int an;
};
struct elev {
 char nume[30];
 struct data data_nasterii;
 float media;
}ev;

Raspuns:ev.data_nasterii.an = 1998;
        </pre>
    </p>
    <p>
        <pre style="
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 40px;
    border-radius: 16px;
    color: white;
    font-size: 24px;
    box-shadow: 0 0 20px rgba(0,0,0,0.3);">
<b>Fie declarările de mai jos. Dacă variabila x retine informaţii despre 30 de elevi,
 precizaţi care este varianta corectă ce afişează numele şi media elevului al 11-lea?</b>

struct elev{
             char nume[30];
             float media;
           };
elev x[30];

Raspuns:cout##x[10].nume##' '##x[10].media;
        </pre>
    </p>
    <p>
        <pre style="
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 40px;
    border-radius: 16px;
    color: white;
    font-size: 24px;
    box-shadow: 0 0 20px rgba(0,0,0,0.3);">
<b>Se consideră declarările următoare.Care este tipul expresiei x.x.y?</b>

    struct A
    { int x;
    char y;
    };
    struct B
    { float x;
    long y;
    };
    struct C
    { struct A x;
    struct B y;
    } x, y;

Raspuns:char
        </pre>
    </p>
    



    
    <h4 style="text-align: center;font-size:500%;font-family:'Times New Roman', Times, serif ;text-transform: uppercase;color: rgb(127, 221, 255);" id="recursivitate">
        Recursivitate
    </h4>
    <p>
        <pre style="
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 40px;
    border-radius: 16px;
    color: white;
    font-size: 24px;
    box-shadow: 0 0 20px rgba(0,0,0,0.3);">
    
            Funcţia F are definiţia alăturată. Ce valoar are F(3)?  | int F(int n)                                                       
                                                                    |{
                                                                    |   if(n==0 || n==1) 
                                                                    |        return 1;
                                                                    |    else
                                                                    |        return 2*F(n-1)+2*F(n-2);
                                                                    |}
                                                                    |
                                                                    
            f(3)-> return 2*f(2)+2*f(1)    ---> f(1)->n==1 => 1
                                           ---> f(2)-> return 2*f(1)+2*f(0) --->f(0)=>1
                                                                            --->f(1)=>1
                                                =>4
                =>2*4+2*1
                =>10
        </pre>
    </p>
    <p>
        <pre style="
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 40px;
    border-radius: 16px;
    color: white;
    font-size: 24px;
    box-shadow: 0 0 20px rgba(0,0,0,0.3);">
            Subprogramul f are definiţia alăturată. Ce se va afişa | void f(long n) 
                în urma apelului f(12345);?                        |{
                                                                   |    if (n>9) 
                                                                   |    { 
                                                                   |        cout<#n/100;
                                                                   |        f(n/10);
                                                                   |    }
                                                                   |}
                                                                   |
            f(12345)---> 123
                        f(1234)==> f(1234)---> 12
                                               f(123)==> f(123)---> 1
                                                                    f(12)==> f(12)---> 0
                                                                                       f(1)==> f(1)
            R: 1231210
        </pre>
    </p>
    <p>
        <pre style="
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 40px;
    border-radius: 16px;
    color: white;
    font-size: 24px;
    box-shadow: 0 0 20px rgba(0,0,0,0.3);">
        Subprogramul F este definit mai jos.    |void F(char c)
           Ce se afişează în urma apelului      |{
              F('d');                           |   if(c>='a')
                                                |   {
                                                |      cout<#c; 
                                                |      F(c-1); 
                                                |   }
                                                |}
                                                |
        F('d')---> d
                   F('c')==> F('c')---> c
                                        F('b')==> F('b')---> b
                                                             F('a')==> f('a')---> a
        R: dcba

        </pre>
    </p>
    </p>
    <p>
        <pre style="
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 40px;
    border-radius: 16px;
    color: white;
    font-size: 24px;
    box-shadow: 0 0 20px rgba(0,0,0,0.3);">
        Subprogramul F este definit mai jos:

    void F (long a, int b)      |F(154678,3)=>154678%2=0(A)=>cout 8
    { if(a*b!=0)                |F(15467,2)=>15467%2=0(F)=>cout ...
        if(a%2==0)              |F(1546,3)=>1546%2=0(A)=>cout 6
        { cout<#a%10;           |F(154,2)=>154%2=0(A)=>cout 4
        F(a/10,b-1);            |F(15,1)=>15%2=0(F)=>cout ...
        }                       |F(1,2)=>1%2=0(F)=>cout ...
        else                    |F(0,3)=>//INAPOI
        { F(a/10,b+1);          |F(1,2)=>cout 1
        cout<#a%10;             |F(15,1)=>cout 5
        }                       |F(15467,2)=>cout 7
    }                           |Raspuns:864157
    F(154678,3)=?

        </pre>
    </p>
    </p>
    <p>
        <pre style="
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 40px;
    border-radius: 16px;
    color: white;
    font-size: 24px;
    box-shadow: 0 0 20px rgba(0,0,0,0.3);">
        Se consideră subprogramul f, definit mai jos. |int f(int x)
            Care este rezultatul apelului f(20)?      |{
                                                      |     if(x<=0)
                                                      |         return 0;
                                                      |     return x+f(x-5);
                                                      |}
                                                      |
        f(20)---> return 20+f(15)==> f(15)---> return 15+f(10)==> f(10)---> return 10+f(5)==> f(5)---> return 5+f(0)==> f(0)---> 0
                                                                                                            =>5+0
                                                                                  =>10+5
                                                        =>15+15
                        20+30
        R: 50                          
        </pre>
    </p>

    <h5 style="text-align: center;font-size:500%;font-family:'Times New Roman', Times, serif ;text-transform: uppercase;color: rgb(127, 221, 255);" id="divide et impera">
        DIVIDE ET IMPERA
    </h5>
    </p>
    <p>
        <pre style="
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 40px;
    border-radius: 16px;
    color: white;
    font-size: 24px;
    box-shadow: 0 0 20px rgba(0,0,0,0.3);">
    <h1>Căutare Binară</h1>
    <b>Se dă un vector x cu n elemente numere naturale, ordonate crescător, și un vector y cu m elemente, 
        de asemenea numere naturale. Verificați pentru fiecare element al vectorului y dacă apare în x.</b>

        #include #iostream>
        using namespace std;

        bool CautBin (int x[],int n,int st,int dr,int z)
        {
            if(z<#x[1] || z>x[n])
                return 0;
            st=1;
            dr=n;
            while(st<=dr)
            {
                int mij=(st+dr)/2;
                if(z==x[mij])
                    return 1;
                else if(z<#x[mij])
                    dr=mij-1;
                else
                    st=mij+1;
            }
            return 0;
        }

        int main()
        {
            int n,st,dr,m;
            cin>>n;
            int x[n+1];
            for(int i=1;i<=n;++i)
                cin>>x[i];
            cin>>m;
            for(int i=1;i<=m;++i)
            {
                int w;
                cin>>w;
                cout<#CautBin(x,n,st,dr,w)<<' ';
            }

            return 0;
        }
        </pre>
    </p>

    </p>
    <p>
        <pre style="
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 40px;
    border-radius: 16px;
    color: white;
    font-size: 24px;
    box-shadow: 0 0 20px rgba(0,0,0,0.3);">
    <h1>INTERCLASARE</h1>
<b>Se dau două mulțimi de numere naturale. Să se afișeze reuniunea și intersecția lor.</b> 

#include #iostream>

using namespace std;

int main()
{
    int n, m, k1 = 0, k2 = 0;
    int a[100001], b[100001], c[200001], d[100001];
    cin >> n;
    for(int i = 1; i <= n; ++i)
        cin >> a[i];
    cin >> m;
    for(int i = 1; i <= m; ++i)
        cin >> b[i];
    int i = 1, j = 1;
    while(i <= n && j <= m)
        if(a[i] < b[j])
            c[++k1] = a[i], i++;
        else
            if(a[i] > b[j])
                c[++k1] = b[j], j++;
            else
                i++;
    while(i <= n)
        c[++k1] = a[i], i++;
    while(j <= m)
        c[++k1] = b[j], j++;
    i = 1, j = 1;
    while(i <= n && j <= m)
        if(a[i] == b[j])
            d[++k2] = a[i], i++, j++;
        else
            if(a[i] < b[j])
                i++;
            else
                j++;
    for(int i = 1; i <= k1; ++i)
        cout << c[i] << " ";
    cout << endl;
    for(int i = 1; i <= k2; ++i)
        cout << d[i] << " ";
    return 0;
}
        </pre>
    </p>

  </div>

  <script>
    function openSidebar() {
      document.getElementById("mySidebar").style.width = "250px";
    }

    function closeSidebar() {
      document.getElementById("mySidebar").style.width = "0";
    }
  </script>

</body>
</html>
